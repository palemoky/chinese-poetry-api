package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/palemoky/chinese-poetry-api/internal/database"
	"github.com/palemoky/chinese-poetry-api/internal/graph/generated"
	"github.com/palemoky/chinese-poetry-api/internal/graph/model"
	"github.com/palemoky/chinese-poetry-api/internal/search"
)

// Poems is the resolver for the poems field.
func (r *authorResolver) Poems(ctx context.Context, obj *database.Author, page *int, pageSize *int) (*database.PoemConnection, error) {
	// Default pagination values
	p := 1
	if page != nil && *page > 0 {
		p = *page
	}
	ps := 20
	if pageSize != nil && *pageSize > 0 {
		ps = *pageSize
		if ps > 100 {
			ps = 100 // Limit max page size
		}
	}

	offset := (p - 1) * ps

	// Get author's poems with total count
	poems, totalCount, err := r.Repo.ListAuthorPoems(obj.ID, ps, offset)
	if err != nil {
		return nil, err
	}

	// Build edges
	edges := make([]database.PoemEdge, len(poems))
	for i, poem := range poems {
		edges[i] = database.PoemEdge{
			Node:   poem,
			Cursor: strconv.Itoa(offset + i),
		}
	}

	// Build page info
	hasNextPage := offset+len(poems) < totalCount
	hasPreviousPage := p > 1

	var startCursor, endCursor *string
	if len(edges) > 0 {
		start := edges[0].Cursor
		end := edges[len(edges)-1].Cursor
		startCursor = &start
		endCursor = &end
	}

	return &database.PoemConnection{
		Edges: edges,
		PageInfo: database.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: totalCount,
	}, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *authorResolver) PoemCount(ctx context.Context, obj *database.Author) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("author_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// Node is the resolver for the node field.
func (r *authorEdgeResolver) Node(ctx context.Context, obj *database.AuthorEdge) (*database.Author, error) {
	return &obj.Node.Author, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *dynastyResolver) PoemCount(ctx context.Context, obj *database.Dynasty) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("dynasty_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// AuthorCount is the resolver for the authorCount field.
func (r *dynastyResolver) AuthorCount(ctx context.Context, obj *database.Dynasty) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("dynasty_id = ?", obj.ID).Distinct("author_id").Count(&count).Error
	return int(count), err
}

// Content is the resolver for the content field.
func (r *poemResolver) Content(ctx context.Context, obj *database.Poem) ([]string, error) {
	var content []string
	if err := json.Unmarshal(obj.Content, &content); err != nil {
		return nil, err
	}
	return content, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *poetryTypeResolver) PoemCount(ctx context.Context, obj *database.PoetryType) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("type_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// Poem is the resolver for the poem field.
func (r *queryResolver) Poem(ctx context.Context, id string) (*database.Poem, error) {
	poem, err := r.Repo.GetPoemByID(id)
	if err != nil {
		return nil, err
	}
	return poem, nil
}

// Poems is the resolver for the poems field.
func (r *queryResolver) Poems(ctx context.Context, page *int, pageSize *int, dynastyID *string, authorID *string, typeID *string) (*database.PoemConnection, error) {
	// Default pagination values
	p := 1
	if page != nil && *page > 0 {
		p = *page
	}
	ps := 20
	if pageSize != nil && *pageSize > 0 {
		ps = *pageSize
		if ps > 100 {
			ps = 100 // Limit max page size
		}
	}

	offset := (p - 1) * ps

	// Parse filter IDs
	var dynastyIDInt, authorIDInt, typeIDInt *int64
	if dynastyID != nil && *dynastyID != "" {
		id, err := strconv.ParseInt(*dynastyID, 10, 64)
		if err != nil {
			return nil, err
		}
		dynastyIDInt = &id
	}
	if authorID != nil && *authorID != "" {
		id, err := strconv.ParseInt(*authorID, 10, 64)
		if err != nil {
			return nil, err
		}
		authorIDInt = &id
	}
	if typeID != nil && *typeID != "" {
		id, err := strconv.ParseInt(*typeID, 10, 64)
		if err != nil {
			return nil, err
		}
		typeIDInt = &id
	}

	// Get filtered poems with total count
	poems, totalCount, err := r.Repo.ListPoemsWithFilter(ps, offset, dynastyIDInt, authorIDInt, typeIDInt)
	if err != nil {
		return nil, err
	}

	// Build edges
	edges := make([]database.PoemEdge, len(poems))
	for i, poem := range poems {
		edges[i] = database.PoemEdge{
			Node:   poem,
			Cursor: strconv.Itoa(offset + i),
		}
	}

	// Build page info
	hasNextPage := offset+len(poems) < totalCount
	hasPreviousPage := p > 1

	var startCursor, endCursor *string
	if len(edges) > 0 {
		start := edges[0].Cursor
		end := edges[len(edges)-1].Cursor
		startCursor = &start
		endCursor = &end
	}

	return &database.PoemConnection{
		Edges: edges,
		PageInfo: database.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: totalCount,
	}, nil
}

// SearchPoems is the resolver for the searchPoems field.
func (r *queryResolver) SearchPoems(ctx context.Context, query string, searchType *model.SearchType, page *int, pageSize *int) (*database.PoemConnection, error) {
	p := 1
	if page != nil {
		p = *page
	}
	ps := 20
	if pageSize != nil {
		ps = *pageSize
	}

	st := search.SearchTypeAll
	if searchType != nil {
		switch *searchType {
		case model.SearchTypeTitle:
			st = search.SearchTypeTitle
		case model.SearchTypeContent:
			st = search.SearchTypeContent
		case model.SearchTypeAuthor:
			st = search.SearchTypeAuthor
		}
	}

	result, err := r.Search.Search(search.SearchParams{
		Query:      query,
		SearchType: st,
		Page:       p,
		PageSize:   ps,
	})
	if err != nil {
		return nil, err
	}

	edges := make([]database.PoemEdge, len(result.Poems))
	for i, poem := range result.Poems {
		edges[i] = database.PoemEdge{
			Node:   poem,
			Cursor: strconv.Itoa(i),
		}
	}

	return &database.PoemConnection{
		Edges:      edges,
		PageInfo:   database.PageInfo{HasNextPage: result.HasMore, HasPreviousPage: p > 1},
		TotalCount: result.TotalCount,
	}, nil
}

// RandomPoem is the resolver for the randomPoem field.
func (r *queryResolver) RandomPoem(ctx context.Context, dynastyID *string, typeID *string) (*database.Poem, error) {
	// Simple random query
	var id string
	if err := r.DB.Raw(`SELECT id FROM poems ORDER BY RANDOM() LIMIT 1`).Scan(&id).Error; err != nil {
		return nil, err
	}

	poem, err := r.Repo.GetPoemByID(id)
	if err != nil {
		return nil, err
	}
	return poem, nil
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id string) (*database.Author, error) {
	authorID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}

	var author database.Author
	err = r.DB.Preload("Dynasty").First(&author, authorID).Error
	if err != nil {
		return nil, err
	}
	return &author, nil
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context, page *int, pageSize *int, dynastyID *string) (*database.AuthorConnection, error) {
	// Default pagination values
	p := 1
	if page != nil && *page > 0 {
		p = *page
	}
	ps := 20
	if pageSize != nil && *pageSize > 0 {
		ps = *pageSize
		if ps > 100 {
			ps = 100 // Limit max page size
		}
	}

	offset := (p - 1) * ps

	// Parse dynasty filter
	var dynastyIDInt *int64
	if dynastyID != nil && *dynastyID != "" {
		id, err := strconv.ParseInt(*dynastyID, 10, 64)
		if err != nil {
			return nil, err
		}
		dynastyIDInt = &id
	}

	// Get filtered authors with total count
	authors, totalCount, err := r.Repo.ListAuthorsWithFilter(ps, offset, dynastyIDInt)
	if err != nil {
		return nil, err
	}

	// Build edges
	edges := make([]database.AuthorEdge, len(authors))
	for i, author := range authors {
		edges[i] = database.AuthorEdge{
			Node:   author,
			Cursor: strconv.Itoa(offset + i),
		}
	}

	// Build page info
	hasNextPage := offset+len(authors) < totalCount
	hasPreviousPage := p > 1

	var startCursor, endCursor *string
	if len(edges) > 0 {
		start := edges[0].Cursor
		end := edges[len(edges)-1].Cursor
		startCursor = &start
		endCursor = &end
	}

	return &database.AuthorConnection{
		Edges: edges,
		PageInfo: database.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: totalCount,
	}, nil
}

// Dynasties is the resolver for the dynasties field.
func (r *queryResolver) Dynasties(ctx context.Context) ([]*database.Dynasty, error) {
	var dynasties []*database.Dynasty
	err := r.DB.Order("id").Find(&dynasties).Error
	if err != nil {
		return nil, err
	}
	return dynasties, nil
}

// PoemTypes is the resolver for the poemTypes field.
func (r *queryResolver) PoemTypes(ctx context.Context) ([]*database.PoetryType, error) {
	var types []*database.PoetryType
	err := r.DB.Order("id").Find(&types).Error
	if err != nil {
		return nil, err
	}
	return types, nil
}

// Statistics is the resolver for the statistics field.
func (r *queryResolver) Statistics(ctx context.Context) (*database.Statistics, error) {
	return r.Repo.GetStatistics()
}

// PoemsByDynasty is the resolver for the poemsByDynasty field.
func (r *statisticsResolver) PoemsByDynasty(ctx context.Context, obj *database.Statistics) ([]*model.DynastyStats, error) {
	stats := make([]*model.DynastyStats, len(obj.PoemsByDynasty))
	for i, ds := range obj.PoemsByDynasty {
		stats[i] = &model.DynastyStats{
			Dynasty: &ds.Dynasty,
			Count:   ds.PoemCount,
		}
	}
	return stats, nil
}

// PoemsByType is the resolver for the poemsByType field.
func (r *statisticsResolver) PoemsByType(ctx context.Context, obj *database.Statistics) ([]*model.TypeStats, error) {
	stats := make([]*model.TypeStats, len(obj.PoemsByType))
	for i, ts := range obj.PoemsByType {
		stats[i] = &model.TypeStats{
			Type:  &ts.PoetryType,
			Count: ts.PoemCount,
		}
	}
	return stats, nil
}

// Author returns generated.AuthorResolver implementation.
func (r *Resolver) Author() generated.AuthorResolver { return &authorResolver{r} }

// AuthorEdge returns generated.AuthorEdgeResolver implementation.
func (r *Resolver) AuthorEdge() generated.AuthorEdgeResolver { return &authorEdgeResolver{r} }

// Dynasty returns generated.DynastyResolver implementation.
func (r *Resolver) Dynasty() generated.DynastyResolver { return &dynastyResolver{r} }

// Poem returns generated.PoemResolver implementation.
func (r *Resolver) Poem() generated.PoemResolver { return &poemResolver{r} }

// PoetryType returns generated.PoetryTypeResolver implementation.
func (r *Resolver) PoetryType() generated.PoetryTypeResolver { return &poetryTypeResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Statistics returns generated.StatisticsResolver implementation.
func (r *Resolver) Statistics() generated.StatisticsResolver { return &statisticsResolver{r} }

type (
	authorResolver     struct{ *Resolver }
	authorEdgeResolver struct{ *Resolver }
	dynastyResolver    struct{ *Resolver }
	poemResolver       struct{ *Resolver }
	poetryTypeResolver struct{ *Resolver }
	queryResolver      struct{ *Resolver }
	statisticsResolver struct{ *Resolver }
)
