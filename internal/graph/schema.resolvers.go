package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/palemoky/chinese-poetry-api/internal/database"
	"github.com/palemoky/chinese-poetry-api/internal/graph/generated"
	"github.com/palemoky/chinese-poetry-api/internal/graph/model"
	"github.com/palemoky/chinese-poetry-api/internal/search"
)

// Poems is the resolver for the poems field.
func (r *authorResolver) Poems(ctx context.Context, obj *database.Author, page *int, pageSize *int) (*database.PoemConnection, error) {
	pag := parsePagination(page, pageSize)

	poems, totalCount, err := r.Repo.ListAuthorPoems(obj.ID, pag.PageSize, pag.Offset)
	if err != nil {
		return nil, err
	}

	return buildPoemConnection(poems, pag, totalCount), nil
}

// PoemCount is the resolver for the poemCount field.
func (r *authorResolver) PoemCount(ctx context.Context, obj *database.Author) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("author_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// Node is the resolver for the node field.
func (r *authorEdgeResolver) Node(ctx context.Context, obj *database.AuthorEdge) (*database.Author, error) {
	return &obj.Node.Author, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *dynastyResolver) PoemCount(ctx context.Context, obj *database.Dynasty) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("dynasty_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// AuthorCount is the resolver for the authorCount field.
func (r *dynastyResolver) AuthorCount(ctx context.Context, obj *database.Dynasty) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("dynasty_id = ?", obj.ID).Distinct("author_id").Count(&count).Error
	return int(count), err
}

// Content is the resolver for the content field.
func (r *poemResolver) Content(ctx context.Context, obj *database.Poem) ([]string, error) {
	var content []string
	if err := json.Unmarshal(obj.Content, &content); err != nil {
		return nil, err
	}
	return content, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *poetryTypeResolver) PoemCount(ctx context.Context, obj *database.PoetryType) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("type_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// Poem is the resolver for the poem field.
func (r *queryResolver) Poem(ctx context.Context, id string, lang *database.Lang) (*database.Poem, error) {
	poem, err := r.Repo.GetPoemByID(id)
	if err != nil {
		return nil, err
	}
	return poem, nil
}

// Poems is the resolver for the poems field.
func (r *queryResolver) Poems(ctx context.Context, lang *database.Lang, page *int, pageSize *int, dynastyID *string, authorID *string, typeID *string) (*database.PoemConnection, error) {
	pag := parsePagination(page, pageSize)

	// Parse filter IDs
	dynastyIDInt, err := parseOptionalID(dynastyID)
	if err != nil {
		return nil, err
	}
	authorIDInt, err := parseOptionalID(authorID)
	if err != nil {
		return nil, err
	}
	typeIDInt, err := parseOptionalID(typeID)
	if err != nil {
		return nil, err
	}

	poems, totalCount, err := r.Repo.ListPoemsWithFilter(pag.PageSize, pag.Offset, dynastyIDInt, authorIDInt, typeIDInt)
	if err != nil {
		return nil, err
	}

	return buildPoemConnection(poems, pag, totalCount), nil
}

// SearchPoems is the resolver for the searchPoems field.
func (r *queryResolver) SearchPoems(ctx context.Context, query string, lang *database.Lang, searchType *model.SearchType, page *int, pageSize *int) (*database.PoemConnection, error) {
	p := 1
	if page != nil {
		p = *page
	}
	ps := 20
	if pageSize != nil {
		ps = *pageSize
	}

	st := search.SearchTypeAll
	if searchType != nil {
		switch *searchType {
		case model.SearchTypeTitle:
			st = search.SearchTypeTitle
		case model.SearchTypeContent:
			st = search.SearchTypeContent
		case model.SearchTypeAuthor:
			st = search.SearchTypeAuthor
		}
	}

	result, err := r.Search.Search(search.SearchParams{
		Query:      query,
		SearchType: st,
		Page:       p,
		PageSize:   ps,
	})
	if err != nil {
		return nil, err
	}

	edges := make([]database.PoemEdge, len(result.Poems))
	for i, poem := range result.Poems {
		edges[i] = database.PoemEdge{
			Node:   poem,
			Cursor: strconv.Itoa(i),
		}
	}

	return &database.PoemConnection{
		Edges:      edges,
		PageInfo:   database.PageInfo{HasNextPage: result.HasMore, HasPreviousPage: p > 1},
		TotalCount: result.TotalCount,
	}, nil
}

// RandomPoem is the resolver for the randomPoem field.
func (r *queryResolver) RandomPoem(ctx context.Context, lang *database.Lang, dynastyID *string, typeID *string) (*database.Poem, error) {
	// Simple random query - use dynamic table name
	poemTable := database.PoemsTable(database.LangHans)
	var id string
	if err := r.DB.Raw(`SELECT id FROM ` + poemTable + ` ORDER BY RANDOM() LIMIT 1`).Scan(&id).Error; err != nil {
		return nil, err
	}

	poem, err := r.Repo.GetPoemByID(id)
	if err != nil {
		return nil, err
	}
	return poem, nil
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id string, lang *database.Lang) (*database.Author, error) {
	authorID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}

	// Use Repository method which handles dynamic table names
	return r.Repo.GetAuthorByID(authorID)
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context, lang *database.Lang, page *int, pageSize *int, dynastyID *string) (*database.AuthorConnection, error) {
	pag := parsePagination(page, pageSize)

	dynastyIDInt, err := parseOptionalID(dynastyID)
	if err != nil {
		return nil, err
	}

	authors, totalCount, err := r.Repo.ListAuthorsWithFilter(pag.PageSize, pag.Offset, dynastyIDInt)
	if err != nil {
		return nil, err
	}

	return buildAuthorConnection(authors, pag, totalCount), nil
}

// Dynasties is the resolver for the dynasties field.
func (r *queryResolver) Dynasties(ctx context.Context, lang *database.Lang) ([]*database.Dynasty, error) {
	var dynasties []*database.Dynasty
	langVal := parseLang(lang)
	err := r.DB.Table(database.DynastiesTable(langVal)).Order("id").Find(&dynasties).Error
	if err != nil {
		return nil, err
	}
	return dynasties, nil
}

// PoemTypes is the resolver for the poemTypes field.
func (r *queryResolver) PoemTypes(ctx context.Context, lang *database.Lang) ([]*database.PoetryType, error) {
	var types []*database.PoetryType
	langVal := parseLang(lang)
	err := r.DB.Table(database.PoetryTypesTable(langVal)).Order("id").Find(&types).Error
	if err != nil {
		return nil, err
	}
	return types, nil
}

// Statistics is the resolver for the statistics field.
func (r *queryResolver) Statistics(ctx context.Context, lang *database.Lang) (*database.Statistics, error) {
	return r.Repo.GetStatistics()
}

// PoemsByDynasty is the resolver for the poemsByDynasty field.
func (r *statisticsResolver) PoemsByDynasty(ctx context.Context, obj *database.Statistics) ([]*model.DynastyStats, error) {
	stats := make([]*model.DynastyStats, len(obj.PoemsByDynasty))
	for i, ds := range obj.PoemsByDynasty {
		stats[i] = &model.DynastyStats{
			Dynasty: &ds.Dynasty,
			Count:   ds.PoemCount,
		}
	}
	return stats, nil
}

// PoemsByType is the resolver for the poemsByType field.
func (r *statisticsResolver) PoemsByType(ctx context.Context, obj *database.Statistics) ([]*model.TypeStats, error) {
	stats := make([]*model.TypeStats, len(obj.PoemsByType))
	for i, ts := range obj.PoemsByType {
		stats[i] = &model.TypeStats{
			Type:  &ts.PoetryType,
			Count: ts.PoemCount,
		}
	}
	return stats, nil
}

// Author returns generated.AuthorResolver implementation.
func (r *Resolver) Author() generated.AuthorResolver { return &authorResolver{r} }

// AuthorEdge returns generated.AuthorEdgeResolver implementation.
func (r *Resolver) AuthorEdge() generated.AuthorEdgeResolver { return &authorEdgeResolver{r} }

// Dynasty returns generated.DynastyResolver implementation.
func (r *Resolver) Dynasty() generated.DynastyResolver { return &dynastyResolver{r} }

// Poem returns generated.PoemResolver implementation.
func (r *Resolver) Poem() generated.PoemResolver { return &poemResolver{r} }

// PoetryType returns generated.PoetryTypeResolver implementation.
func (r *Resolver) PoetryType() generated.PoetryTypeResolver { return &poetryTypeResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Statistics returns generated.StatisticsResolver implementation.
func (r *Resolver) Statistics() generated.StatisticsResolver { return &statisticsResolver{r} }

type (
	authorResolver     struct{ *Resolver }
	authorEdgeResolver struct{ *Resolver }
	dynastyResolver    struct{ *Resolver }
	poemResolver       struct{ *Resolver }
	poetryTypeResolver struct{ *Resolver }
	queryResolver      struct{ *Resolver }
	statisticsResolver struct{ *Resolver }
)
