package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/palemoky/chinese-poetry-api/internal/database"
	"github.com/palemoky/chinese-poetry-api/internal/graph/generated"
	"github.com/palemoky/chinese-poetry-api/internal/graph/model"
	"github.com/palemoky/chinese-poetry-api/internal/search"
)

// Dynasty is the resolver for the dynasty field.
func (r *authorResolver) Dynasty(ctx context.Context, obj *database.Author) (*database.Dynasty, error) {
	if obj.DynastyID == nil {
		return nil, nil
	}

	var dynasty database.Dynasty
	err := r.DB.First(&dynasty, *obj.DynastyID).Error
	if err != nil {
		return nil, err
	}
	return &dynasty, nil
}

// Poems is the resolver for the poems field.
func (r *authorResolver) Poems(ctx context.Context, obj *database.Author, page *int, pageSize *int) (*database.PoemConnection, error) {
	// TODO: Implement pagination for author's poems
	return &database.PoemConnection{
		Edges:      []database.PoemEdge{},
		PageInfo:   database.PageInfo{HasNextPage: false, HasPreviousPage: false},
		TotalCount: 0,
	}, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *authorResolver) PoemCount(ctx context.Context, obj *database.Author) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("author_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// Node is the resolver for the node field.
func (r *authorEdgeResolver) Node(ctx context.Context, obj *database.AuthorEdge) (*database.Author, error) {
	return &obj.Node.Author, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *dynastyResolver) PoemCount(ctx context.Context, obj *database.Dynasty) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("dynasty_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// AuthorCount is the resolver for the authorCount field.
func (r *dynastyResolver) AuthorCount(ctx context.Context, obj *database.Dynasty) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("dynasty_id = ?", obj.ID).Distinct("author_id").Count(&count).Error
	return int(count), err
}

// Paragraphs is the resolver for the paragraphs field.
func (r *poemResolver) Paragraphs(ctx context.Context, obj *database.Poem) ([]string, error) {
	var paragraphs []string
	if err := json.Unmarshal(obj.Content, &paragraphs); err != nil {
		return nil, err
	}
	return paragraphs, nil
}

// Author is the resolver for the author field.
func (r *poemResolver) Author(ctx context.Context, obj *database.Poem) (*database.Author, error) {
	if obj.AuthorID == nil {
		return nil, nil
	}

	// If already loaded via Preload
	if obj.Author != nil {
		return obj.Author, nil
	}

	var author database.Author
	err := r.DB.First(&author, *obj.AuthorID).Error
	if err != nil {
		return nil, err
	}
	return &author, nil
}

// Dynasty is the resolver for the dynasty field.
func (r *poemResolver) Dynasty(ctx context.Context, obj *database.Poem) (*database.Dynasty, error) {
	if obj.DynastyID == nil {
		return nil, nil
	}

	// If already loaded via Preload
	if obj.Dynasty != nil {
		return obj.Dynasty, nil
	}

	var dynasty database.Dynasty
	err := r.DB.First(&dynasty, *obj.DynastyID).Error
	if err != nil {
		return nil, err
	}
	return &dynasty, nil
}

// Type is the resolver for the type field.
func (r *poemResolver) Type(ctx context.Context, obj *database.Poem) (*database.PoetryType, error) {
	if obj.TypeID == nil {
		return nil, nil
	}

	// If already loaded via Preload
	if obj.Type != nil {
		return obj.Type, nil
	}

	var poetryType database.PoetryType
	err := r.DB.First(&poetryType, *obj.TypeID).Error
	if err != nil {
		return nil, err
	}
	return &poetryType, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *poemResolver) CreatedAt(ctx context.Context, obj *database.Poem) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// Node is the resolver for the node field.
func (r *poemEdgeResolver) Node(ctx context.Context, obj *database.PoemEdge) (*database.Poem, error) {
	return &obj.Node, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *poetryTypeResolver) PoemCount(ctx context.Context, obj *database.PoetryType) (int, error) {
	var count int64
	err := r.DB.Model(&database.Poem{}).Where("type_id = ?", obj.ID).Count(&count).Error
	return int(count), err
}

// Poem is the resolver for the poem field.
func (r *queryResolver) Poem(ctx context.Context, id string) (*database.Poem, error) {
	poem, err := r.Repo.GetPoemByID(id)
	if err != nil {
		return nil, err
	}
	return poem, nil
}

// Poems is the resolver for the poems field.
func (r *queryResolver) Poems(ctx context.Context, page *int, pageSize *int, dynastyID *string, authorID *string, typeID *string) (*database.PoemConnection, error) {
	// TODO: Implement filtering and pagination
	return &database.PoemConnection{
		Edges:      []database.PoemEdge{},
		PageInfo:   database.PageInfo{HasNextPage: false, HasPreviousPage: false},
		TotalCount: 0,
	}, nil
}

// SearchPoems is the resolver for the searchPoems field.
func (r *queryResolver) SearchPoems(ctx context.Context, query string, searchType *model.SearchType, page *int, pageSize *int) (*database.PoemConnection, error) {
	p := 1
	if page != nil {
		p = *page
	}
	ps := 20
	if pageSize != nil {
		ps = *pageSize
	}

	st := search.SearchTypeAll
	if searchType != nil {
		switch *searchType {
		case model.SearchTypeTitle:
			st = search.SearchTypeTitle
		case model.SearchTypeContent:
			st = search.SearchTypeContent
		case model.SearchTypeAuthor:
			st = search.SearchTypeAuthor
		case model.SearchTypePinyin:
			st = search.SearchTypePinyin
		}
	}

	result, err := r.Search.Search(search.SearchParams{
		Query:      query,
		SearchType: st,
		Page:       p,
		PageSize:   ps,
	})
	if err != nil {
		return nil, err
	}

	edges := make([]database.PoemEdge, len(result.Poems))
	for i, poem := range result.Poems {
		edges[i] = database.PoemEdge{
			Node:   poem,
			Cursor: strconv.Itoa(i),
		}
	}

	return &database.PoemConnection{
		Edges:      edges,
		PageInfo:   database.PageInfo{HasNextPage: result.HasMore, HasPreviousPage: p > 1},
		TotalCount: result.TotalCount,
	}, nil
}

// RandomPoem is the resolver for the randomPoem field.
func (r *queryResolver) RandomPoem(ctx context.Context, dynastyID *string, typeID *string) (*database.Poem, error) {
	// Simple random query
	var id string
	if err := r.DB.Raw(`SELECT id FROM poems ORDER BY RANDOM() LIMIT 1`).Scan(&id).Error; err != nil {
		return nil, err
	}

	poem, err := r.Repo.GetPoemByID(id)
	if err != nil {
		return nil, err
	}
	return poem, nil
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id string) (*database.Author, error) {
	authorID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}

	var author database.Author
	err = r.DB.First(&author, authorID).Error
	if err != nil {
		return nil, err
	}
	return &author, nil
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context, page *int, pageSize *int, dynastyID *string) (*database.AuthorConnection, error) {
	// TODO: Implement pagination
	return &database.AuthorConnection{
		Edges:      []database.AuthorEdge{},
		PageInfo:   database.PageInfo{HasNextPage: false, HasPreviousPage: false},
		TotalCount: 0,
	}, nil
}

// Dynasties is the resolver for the dynasties field.
func (r *queryResolver) Dynasties(ctx context.Context) ([]*database.Dynasty, error) {
	var dynasties []*database.Dynasty
	err := r.DB.Order("id").Find(&dynasties).Error
	if err != nil {
		return nil, err
	}
	return dynasties, nil
}

// PoemTypes is the resolver for the poemTypes field.
func (r *queryResolver) PoemTypes(ctx context.Context) ([]*database.PoetryType, error) {
	var types []*database.PoetryType
	err := r.DB.Order("id").Find(&types).Error
	if err != nil {
		return nil, err
	}
	return types, nil
}

// Statistics is the resolver for the statistics field.
func (r *queryResolver) Statistics(ctx context.Context) (*database.Statistics, error) {
	return r.Repo.GetStatistics()
}

// PoemsByDynasty is the resolver for the poemsByDynasty field.
func (r *statisticsResolver) PoemsByDynasty(ctx context.Context, obj *database.Statistics) ([]*model.DynastyStats, error) {
	stats := make([]*model.DynastyStats, len(obj.PoemsByDynasty))
	for i, ds := range obj.PoemsByDynasty {
		stats[i] = &model.DynastyStats{
			Dynasty: &ds.Dynasty,
			Count:   ds.PoemCount,
		}
	}
	return stats, nil
}

// PoemsByType is the resolver for the poemsByType field.
func (r *statisticsResolver) PoemsByType(ctx context.Context, obj *database.Statistics) ([]*model.TypeStats, error) {
	stats := make([]*model.TypeStats, len(obj.PoemsByType))
	for i, ts := range obj.PoemsByType {
		stats[i] = &model.TypeStats{
			Type:  &ts.PoetryType,
			Count: ts.PoemCount,
		}
	}
	return stats, nil
}

// Author returns generated.AuthorResolver implementation.
func (r *Resolver) Author() generated.AuthorResolver { return &authorResolver{r} }

// AuthorEdge returns generated.AuthorEdgeResolver implementation.
func (r *Resolver) AuthorEdge() generated.AuthorEdgeResolver { return &authorEdgeResolver{r} }

// Dynasty returns generated.DynastyResolver implementation.
func (r *Resolver) Dynasty() generated.DynastyResolver { return &dynastyResolver{r} }

// Poem returns generated.PoemResolver implementation.
func (r *Resolver) Poem() generated.PoemResolver { return &poemResolver{r} }

// PoemEdge returns generated.PoemEdgeResolver implementation.
func (r *Resolver) PoemEdge() generated.PoemEdgeResolver { return &poemEdgeResolver{r} }

// PoetryType returns generated.PoetryTypeResolver implementation.
func (r *Resolver) PoetryType() generated.PoetryTypeResolver { return &poetryTypeResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Statistics returns generated.StatisticsResolver implementation.
func (r *Resolver) Statistics() generated.StatisticsResolver { return &statisticsResolver{r} }

type authorResolver struct{ *Resolver }
type authorEdgeResolver struct{ *Resolver }
type dynastyResolver struct{ *Resolver }
type poemResolver struct{ *Resolver }
type poemEdgeResolver struct{ *Resolver }
type poetryTypeResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type statisticsResolver struct{ *Resolver }
