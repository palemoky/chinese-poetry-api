package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/palemoky/chinese-poetry-api/internal/database"
	"github.com/palemoky/chinese-poetry-api/internal/graph/generated"
	"github.com/palemoky/chinese-poetry-api/internal/graph/model"
	"github.com/palemoky/chinese-poetry-api/internal/search"
)

// Dynasty is the resolver for the dynasty field.
func (r *authorResolver) Dynasty(ctx context.Context, obj *database.Author) (*database.Dynasty, error) {
	if obj.DynastyID == nil {
		return nil, nil
	}

	var dynasty database.Dynasty
	err := r.DB.QueryRow(`SELECT id, name, name_en, start_year, end_year, created_at FROM dynasties WHERE id = ?`, *obj.DynastyID).Scan(
		&dynasty.ID, &dynasty.Name, &dynasty.NameEn, &dynasty.StartYear, &dynasty.EndYear, &dynasty.CreatedAt,
	)
	if err != nil {
		return nil, err
	}
	return &dynasty, nil
}

// Poems is the resolver for the poems field.
func (r *authorResolver) Poems(ctx context.Context, obj *database.Author, page *int, pageSize *int) (*database.PoemConnection, error) {
	// TODO: Implement pagination for author's poems
	return &database.PoemConnection{
		Edges:      []database.PoemEdge{},
		PageInfo:   database.PageInfo{HasNextPage: false, HasPreviousPage: false},
		TotalCount: 0,
	}, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *authorResolver) PoemCount(ctx context.Context, obj *database.Author) (int, error) {
	var count int
	err := r.DB.QueryRow(`SELECT COUNT(*) FROM poems WHERE author_id = ?`, obj.ID).Scan(&count)
	return count, err
}

// Node is the resolver for the node field.
func (r *authorEdgeResolver) Node(ctx context.Context, obj *database.AuthorEdge) (*database.Author, error) {
	return &obj.Node.Author, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *dynastyResolver) PoemCount(ctx context.Context, obj *database.Dynasty) (int, error) {
	var count int
	err := r.DB.QueryRow(`SELECT COUNT(*) FROM poems WHERE dynasty_id = ?`, obj.ID).Scan(&count)
	return count, err
}

// AuthorCount is the resolver for the authorCount field.
func (r *dynastyResolver) AuthorCount(ctx context.Context, obj *database.Dynasty) (int, error) {
	var count int
	err := r.DB.QueryRow(`SELECT COUNT(DISTINCT author_id) FROM poems WHERE dynasty_id = ?`, obj.ID).Scan(&count)
	return count, err
}

// Paragraphs is the resolver for the paragraphs field.
func (r *poemResolver) Paragraphs(ctx context.Context, obj *database.Poem) ([]string, error) {
	var paragraphs []string
	if err := json.Unmarshal([]byte(obj.Content), &paragraphs); err != nil {
		return nil, err
	}
	return paragraphs, nil
}

// Author is the resolver for the author field.
func (r *poemResolver) Author(ctx context.Context, obj *database.Poem) (*database.Author, error) {
	if obj.AuthorID == nil {
		return nil, nil
	}

	var author database.Author
	err := r.DB.QueryRow(`SELECT id, name, name_pinyin, name_pinyin_abbr, dynasty_id, description, created_at FROM authors WHERE id = ?`, *obj.AuthorID).Scan(
		&author.ID, &author.Name, &author.NamePinyin, &author.NamePinyinAbbr, &author.DynastyID, &author.Description, &author.CreatedAt,
	)
	if err != nil {
		return nil, err
	}
	return &author, nil
}

// Dynasty is the resolver for the dynasty field.
func (r *poemResolver) Dynasty(ctx context.Context, obj *database.Poem) (*database.Dynasty, error) {
	if obj.DynastyID == nil {
		return nil, nil
	}

	var dynasty database.Dynasty
	err := r.DB.QueryRow(`SELECT id, name, name_en, start_year, end_year, created_at FROM dynasties WHERE id = ?`, *obj.DynastyID).Scan(
		&dynasty.ID, &dynasty.Name, &dynasty.NameEn, &dynasty.StartYear, &dynasty.EndYear, &dynasty.CreatedAt,
	)
	if err != nil {
		return nil, err
	}
	return &dynasty, nil
}

// Type is the resolver for the type field.
func (r *poemResolver) Type(ctx context.Context, obj *database.Poem) (*database.PoetryType, error) {
	if obj.TypeID == nil {
		return nil, nil
	}

	var poetryType database.PoetryType
	err := r.DB.QueryRow(`SELECT id, name, category, lines, chars_per_line, description, created_at FROM poetry_types WHERE id = ?`, *obj.TypeID).Scan(
		&poetryType.ID, &poetryType.Name, &poetryType.Category, &poetryType.Lines, &poetryType.CharsPerLine, &poetryType.Description, &poetryType.CreatedAt,
	)
	if err != nil {
		return nil, err
	}
	return &poetryType, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *poemResolver) CreatedAt(ctx context.Context, obj *database.Poem) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// Node is the resolver for the node field.
func (r *poemEdgeResolver) Node(ctx context.Context, obj *database.PoemEdge) (*database.Poem, error) {
	return &obj.Node.Poem, nil
}

// PoemCount is the resolver for the poemCount field.
func (r *poetryTypeResolver) PoemCount(ctx context.Context, obj *database.PoetryType) (int, error) {
	var count int
	err := r.DB.QueryRow(`SELECT COUNT(*) FROM poems WHERE type_id = ?`, obj.ID).Scan(&count)
	return count, err
}

// Poem is the resolver for the poem field.
func (r *queryResolver) Poem(ctx context.Context, id string) (*database.Poem, error) {
	poem, err := r.Repo.GetPoemByID(id)
	if err != nil {
		return nil, err
	}
	return &poem.Poem, nil
}

// Poems is the resolver for the poems field.
func (r *queryResolver) Poems(ctx context.Context, page *int, pageSize *int, dynastyID *string, authorID *string, typeID *string) (*database.PoemConnection, error) {
	// TODO: Implement filtering and pagination
	return &database.PoemConnection{
		Edges:      []database.PoemEdge{},
		PageInfo:   database.PageInfo{HasNextPage: false, HasPreviousPage: false},
		TotalCount: 0,
	}, nil
}

// SearchPoems is the resolver for the searchPoems field.
func (r *queryResolver) SearchPoems(ctx context.Context, query string, searchType *model.SearchType, page *int, pageSize *int) (*database.PoemConnection, error) {
	p := 1
	if page != nil {
		p = *page
	}
	ps := 20
	if pageSize != nil {
		ps = *pageSize
	}

	st := search.SearchTypeAll
	if searchType != nil {
		switch *searchType {
		case model.SearchTypeTitle:
			st = search.SearchTypeTitle
		case model.SearchTypeContent:
			st = search.SearchTypeContent
		case model.SearchTypeAuthor:
			st = search.SearchTypeAuthor
		case model.SearchTypePinyin:
			st = search.SearchTypePinyin
		}
	}

	result, err := r.Search.Search(search.SearchParams{
		Query:      query,
		SearchType: st,
		Page:       p,
		PageSize:   ps,
	})
	if err != nil {
		return nil, err
	}

	edges := make([]database.PoemEdge, len(result.Poems))
	for i, poem := range result.Poems {
		edges[i] = database.PoemEdge{
			Node:   poem,
			Cursor: strconv.Itoa(i),
		}
	}

	return &database.PoemConnection{
		Edges:      edges,
		PageInfo:   database.PageInfo{HasNextPage: result.HasMore, HasPreviousPage: p > 1},
		TotalCount: result.TotalCount,
	}, nil
}

// RandomPoem is the resolver for the randomPoem field.
func (r *queryResolver) RandomPoem(ctx context.Context, dynastyID *string, typeID *string) (*database.Poem, error) {
	// Simple random query
	query := `SELECT id FROM poems ORDER BY RANDOM() LIMIT 1`
	var id string
	if err := r.DB.QueryRow(query).Scan(&id); err != nil {
		return nil, err
	}

	poem, err := r.Repo.GetPoemByID(id)
	if err != nil {
		return nil, err
	}
	return &poem.Poem, nil
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id string) (*database.Author, error) {
	authorID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}

	var author database.Author
	err = r.DB.QueryRow(`SELECT id, name, name_pinyin, name_pinyin_abbr, dynasty_id, description, created_at FROM authors WHERE id = ?`, authorID).Scan(
		&author.ID, &author.Name, &author.NamePinyin, &author.NamePinyinAbbr, &author.DynastyID, &author.Description, &author.CreatedAt,
	)
	if err != nil {
		return nil, err
	}
	return &author, nil
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context, page *int, pageSize *int, dynastyID *string) (*database.AuthorConnection, error) {
	// TODO: Implement pagination
	return &database.AuthorConnection{
		Edges:      []database.AuthorEdge{},
		PageInfo:   database.PageInfo{HasNextPage: false, HasPreviousPage: false},
		TotalCount: 0,
	}, nil
}

// Dynasties is the resolver for the dynasties field.
func (r *queryResolver) Dynasties(ctx context.Context) ([]*database.Dynasty, error) {
	rows, err := r.DB.Query(`SELECT id, name, name_en, start_year, end_year, created_at FROM dynasties ORDER BY id`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var dynasties []*database.Dynasty
	for rows.Next() {
		var d database.Dynasty
		if err := rows.Scan(&d.ID, &d.Name, &d.NameEn, &d.StartYear, &d.EndYear, &d.CreatedAt); err != nil {
			return nil, err
		}
		dynasties = append(dynasties, &d)
	}
	return dynasties, rows.Err()
}

// PoemTypes is the resolver for the poemTypes field.
func (r *queryResolver) PoemTypes(ctx context.Context) ([]*database.PoetryType, error) {
	rows, err := r.DB.Query(`SELECT id, name, category, lines, chars_per_line, description, created_at FROM poetry_types ORDER BY id`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var types []*database.PoetryType
	for rows.Next() {
		var t database.PoetryType
		if err := rows.Scan(&t.ID, &t.Name, &t.Category, &t.Lines, &t.CharsPerLine, &t.Description, &t.CreatedAt); err != nil {
			return nil, err
		}
		types = append(types, &t)
	}
	return types, rows.Err()
}

// Statistics is the resolver for the statistics field.
func (r *queryResolver) Statistics(ctx context.Context) (*database.Statistics, error) {
	return r.Repo.GetStatistics()
}

// PoemsByDynasty is the resolver for the poemsByDynasty field.
func (r *statisticsResolver) PoemsByDynasty(ctx context.Context, obj *database.Statistics) ([]*model.DynastyStats, error) {
	stats := make([]*model.DynastyStats, len(obj.PoemsByDynasty))
	for i, ds := range obj.PoemsByDynasty {
		stats[i] = &model.DynastyStats{
			Dynasty: &ds.Dynasty,
			Count:   ds.PoemCount,
		}
	}
	return stats, nil
}

// PoemsByType is the resolver for the poemsByType field.
func (r *statisticsResolver) PoemsByType(ctx context.Context, obj *database.Statistics) ([]*model.TypeStats, error) {
	stats := make([]*model.TypeStats, len(obj.PoemsByType))
	for i, ts := range obj.PoemsByType {
		stats[i] = &model.TypeStats{
			Type:  &ts.PoetryType,
			Count: ts.PoemCount,
		}
	}
	return stats, nil
}

// Author returns generated.AuthorResolver implementation.
func (r *Resolver) Author() generated.AuthorResolver { return &authorResolver{r} }

// AuthorEdge returns generated.AuthorEdgeResolver implementation.
func (r *Resolver) AuthorEdge() generated.AuthorEdgeResolver { return &authorEdgeResolver{r} }

// Dynasty returns generated.DynastyResolver implementation.
func (r *Resolver) Dynasty() generated.DynastyResolver { return &dynastyResolver{r} }

// Poem returns generated.PoemResolver implementation.
func (r *Resolver) Poem() generated.PoemResolver { return &poemResolver{r} }

// PoemEdge returns generated.PoemEdgeResolver implementation.
func (r *Resolver) PoemEdge() generated.PoemEdgeResolver { return &poemEdgeResolver{r} }

// PoetryType returns generated.PoetryTypeResolver implementation.
func (r *Resolver) PoetryType() generated.PoetryTypeResolver { return &poetryTypeResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Statistics returns generated.StatisticsResolver implementation.
func (r *Resolver) Statistics() generated.StatisticsResolver { return &statisticsResolver{r} }

type authorResolver struct{ *Resolver }
type authorEdgeResolver struct{ *Resolver }
type dynastyResolver struct{ *Resolver }
type poemResolver struct{ *Resolver }
type poemEdgeResolver struct{ *Resolver }
type poetryTypeResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type statisticsResolver struct{ *Resolver }
